#!/usr/bin/env python

# Archipelago, a multi-user dungeon (MUD) server, by Martin Keegan
#
# Copyright (C) 2009-2012  Martin Keegan
#
# This programme is free software; you may redistribute and/or modify
# it under the terms of the GNU Affero General Public Licence as published by
# the Free Software Foundation, either version 3 of said Licence, or
# (at your option) any later version.

import sys
import curses
import curses.ascii
import curses.wrapper
import time
import socket

from Multiplexer import Multiplexer
from Networking import Socket, zap_cr

class Throbber(object):
    def __init__(self):
        self.text = '/|\\-'
        self.state = 0
    def next(self):
        self.state += 1
        self.state %= len(self.text)
        return self.text[self.state]

class ServerLink(Socket):
    def __init__(self, address, ss=None):
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        super(ServerLink, self).__init__(sock, address)
        self.connect(address)
        self.setNonBlocking()
        self.ss = ss
        self.ss.set_sock(self)

    def connect(self, address):
        self.s.connect(address)

    def newInput(self):
        self.input_buffer = zap_cr.sub('', self.input_buffer, 0)

        y = self.input_buffer.rfind("\n")
        if y == -1:
            return
        to_process = self.input_buffer[0:y]
        self.input_buffer = self.input_buffer[y+1:]
        for i in to_process.split("\n"):
            self.handleLine(i)

    def handleLine(self, line):
        if len(line) >= 4 and line[0] == '\377':
            cmd = line[1:4]
            arg = line[4:]
            self.ss.process_srv_command(cmd, arg)
        else:
            self.ss.emit_line(line)
 
    def EOF(self):
        self.multi.removeSocket(self)
        self.multi.stop()
        self.s.close()
        self.ss.emit_line("Connection closed by foreign host.")
 
class Stdin(Socket):
    def __init__(self):
        super(Stdin, self).__init__(sys.stdin, None)

class SSFE(Stdin):
    def __init__(self, ss=None, **kwargs):
        super(SSFE, self).__init__()
        self.ss = ss

    def handleReadable(self):
        self.ss.handle_input()

class SplitScreen(object):
    HIST_DEPTH = 30

    def __init__(self, scr):
        self.scr = scr
        self.sock = None
        self.prompt = '> '
        self.new_cmd()
        self.history = [""] * self.HIST_DEPTH
        self.hist_pos = 0
        self.cur_hist_depth = 1
        self.bottom_line = 23
        self.password_mode = False
        self.server_link = None
        self.delay_until = None
        self.throbber = Throbber()

    def throb(self):
        self.scr.move(self.bottom_line, 0)
        self.scr.clrtoeol()
        s = self.throbber.next() + " "
        self.scr.addstr(self.bottom_line, 0, s)
        self.scr.refresh()
        now = time.time()
        if now >= self.delay_until:
            self.stop_delay()

    def set_server_link(self, server_link):
        self.server_link = server_link

    def new_cmd(self):
        self.cmd = ''
        self.pos = 0

    def set_sock(self, sock):
        self.sock = sock

    def setup(self):
        self.scr.idlok(True)
        self.scr.scrollok(True)
        self.scr.setscrreg(0, self.bottom_line - 1)
        self.scr.nodelay(True)

    def emit_line(self, line):
        self.scr.scroll(1)
        self.scr.addstr(self.bottom_line - 1, 0, line)
        self.place_cursor()
        self.scr.refresh()

    def write_prompt(self):
        self.scr.addstr(self.bottom_line, 0, self.prompt)
        self.scr.refresh()

    def place_cursor(self):
        self.scr.move(self.bottom_line, len(self.prompt) + self.pos)

    def clear_input(self):
        self.new_cmd()
        self.place_cursor()
        self.scr.clrtoeol()

    def insert_char(self, ch):
        if not self.password_mode:
            c = ch
        else:
            c = '*'
        self.scr.addch(self.bottom_line, len(self.prompt) + self.pos, c)
        self.cmd += chr(ch)
        self.pos += 1

    def backspace(self):
        if self.pos == 0:
            return
        self.cmd = self.cmd[:-1]
        self.pos -= 1
        self.scr.move(self.bottom_line, len(self.prompt) + self.pos)
        self.scr.clrtoeol()

    def record_history(self, cmd):
        self.history[self.hist_pos] = cmd
        self.hist_pos += 1
        if self.cur_hist_depth < self.HIST_DEPTH:
            self.cur_hist_depth += 1
        self.hist_pos %= self.cur_hist_depth

    def send_line(self):
        if self.password_mode:
            line = self.prompt + "*" * len(self.cmd)
        else:
            line = self.prompt + self.cmd
        self.emit_line(line)
        self.sock.emit(self.cmd)

        if not self.password_mode:
            self.record_history(self.cmd)

        self.clear_input()
        self.password_mode = False

    def replace_line(self, s):
        self.clear_input()
        self.scr.addstr(self.bottom_line, len(self.prompt), s)
        self.cmd = s
        self.pos = len(s)

    def do_history(self, d):
        if self.password_mode:
            return
        self.hist_pos += d + self.cur_hist_depth
        self.hist_pos %= self.cur_hist_depth
        self.replace_line(self.history[self.hist_pos])

    def noop(self):
        self.emit_line("not implemented")

    def history_back(self):
        self.do_history(-1)

    def history_fwd(self):
        self.do_history(1)

    def handle_input(self):
        handlers = {
            curses.KEY_UP: self.history_back,
            curses.KEY_DOWN: self.history_fwd,
            curses.KEY_LEFT: self.noop,
            curses.KEY_RIGHT: self.noop,
            curses.KEY_BACKSPACE: self.backspace
            }

        ch = self.scr.getch() ## FIXME -1?

        if self.delay_until:
            now = time.time()
            if now < self.delay_until:
                return
            self.stop_delay()

        if ch >= 32 and ch <= 126:
            self.insert_char(ch)
        elif ch == curses.ascii.LF:
            self.send_line()
        elif ch in handlers:
            handlers[ch]()

        #self.scr.addstr(5,5,str(ch))
        self.scr.refresh()

    def stop_delay(self):
        self.delay_until = None
        self.server_link.multi.setTimeout(5000)
        self.server_link.multi.clearOnTimeout()
        self.write_prompt()
        self.replace_line(self.cmd)
        self.sock.emit("") # cheekily notify the server we're done
        
    def delay(self, delay):
        now = time.time()
        self.delay_until = now + delay
        self.server_link.multi.setTimeout(250)
        self.server_link.multi.setOnTimeout(lambda : self.throb())

    def process_srv_command(self, cmd, arg):
        if cmd == 'PSW':
            self.password_mode = True
        elif cmd == 'PRN':
            self.prompt = arg
            self.write_prompt()
            self.replace_line(self.cmd)
        elif cmd == 'DLY':
            try:
                delay = float(arg)
            except:
                delay = 0.0
            self.delay(delay)
        else:
            self.emit_line("CMD: [%s]" % cmd)
            self.emit_line("ARG: [%s]" % arg)
        
def main(stdscr):
    ss = SplitScreen(stdscr)
    ss.setup()
    ss.write_prompt()

    server = ServerLink(('localhost', 2500), ss=ss)
    stdin = SSFE(ss=ss)

    ss.set_server_link(server)

    m = Multiplexer()
    m.addSocket(server)
    m.addSocket(stdin)
    m.run()
    time.sleep(1)

def run():
    curses.wrapper(main)

if __name__ == '__main__':
    run()
